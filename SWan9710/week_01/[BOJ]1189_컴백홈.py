'''
1. 적용 알고리즘 : 백트래킹(DFS), 너비 우선 탐색
2차원배열 조건에서 길찾기 문제등에 자주 쓰이는 개념
모든 경우의 수를 시도하여 문제를 해결해 나가다 막히면 되돌아 가서
다음 부분을 계산 시도함
====================================================================
2. 접근법
시작지점과 종료지점이 각각 왼쪽아래와 오른쪽 위로 고정되어 있으니
시작지점부터 종료지점까지 도착가능한 모든 경우의 수를 구해보려함
대각선 탐색이란 말이 없으므로 방향이동시 4방향만 고려함
T로 표시된 부분에서는 뒤로 돌아가는 조건 설정해줌
====================================================================
3. 기본 코드에 대한설명
조건
한번 지나친 곳은 다시 방문하지 않는다.
T로 표시된 부분은 지나가지 못하는 부분
R * C 크기의 맵 거리 K
한수가 집까지 도착하는 경우 중 거리가 K인 가짓수 구하기
아래 코드부분에 주석으로 코드 설명 적어둠
====================================================================
4. 실행시간 python => 164ms
'''
import sys
input = sys.stdin.readline

R, C, K = map(int, input().split())
MAP = [list(input().strip()) for _ in range(R)]

# 4방향 탐색
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

# 최종가짓수
result = 0

def DFS(sx, sy, count):
    global result

    # 종료조건
    # 시작지점 왼쪽아래 R-1, 0
    # 도착지점 오른쪽 위 0, C-1
    if count == K and sx == 0 and sy == C-1:
        result += 1
    
    # 백트래킹
    for i in range(4):
        nx = sx + dx[i]
        ny = sy + dy[i]

        # 범위조건 만족 + 이동가능 지점
        if 0 <= nx < R and 0 <= ny < C and MAP[nx][ny] == '.':
            # 방문표시
            MAP[nx][ny] = 'T'
            DFS(nx, ny, count+1)
            MAP[nx][ny] = '.' # 탐색종료 후 원래대로 배열 되돌리기

MAP[R-1][0] = 'T' # 시작지점 이므로 T로 설정 후 DFS 실시
DFS(R-1,0,1) # 시작지점부터 바로 출발이니 count는 1부터 시작

print(result)
