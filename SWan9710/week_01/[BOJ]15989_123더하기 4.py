'''
1. 적용알고리즘 : DP
부분부분의 결과를 저장 후 
필요할 때 재사용 하여 새로운 결과를 도출하는 방식
====================================================================
2. 접근법
2-1. 
우선 1만 사용할 경우에는 어떤 숫자도 1이 나온다는 사실을 알기에 전체
배열을 1로 초기화 시킨후 경우의 수를 계산
2-2 
2가 추가되는 경우 숫자의 위치만 바뀔경우가 어려웠는데 1로 초기화한 전체 배열에서 
마지막 1+1 을 2로 바꾸는 경우만 생각해줌 이렇게 생각하니 전체를
1로 초기화한 배열에서 2로 만들어 지는 경우의 수가 동일한 형식을 반복함
예시)
1+2 => 3
1+1+2 => 4
1+1+1+2 => 5
2-3
3이 추가되는 경우도 2와 동일하게 생각하고 2로 바꾼 배열에 3의 조건을 씌워버리자
라고 생각하고 코드를 짜봄
====================================================================
3. 기본 코드에 대한설명 코드부분에 적어둠
조건
정수 N이 주어졌을때 N을 1,2,3 의 합으로 나타내는 방법의 수를 구해라
합을 구성하는 수의 순서만 다른경우 1개로 친다.
====================================================================
4. 실행시간 => 72ms
====================================================================
'''
import sys
input = sys.stdin.readline

# 1. 1만 이용하기
# 모든배열 1로 초기화
DP = [1] * 10001 # TC가 10000 임

# 2. 1, 2 만 이용하기
# 1로된 배열에서 2를 이용하여 만들수 있는 모든 경우의 수 만들기
'''
4의 경우 2가 들어가면 나올수 있는 경우의 수 2가지
1+1+2, 2+2
숫자의 위치만 바뀌는건 1개로 취급한다 했기 때문

0 1 2 3 4 => 배열의 index
1 1 1 1 |1| -> 이자리가 정수 4에 해당
2칸씩 건너뛰면서 서로 더해주기
1 1 2 2 |3| -> 1의 경우의 수에 2의 경우의 수가 더해진 결과
'''
for i in range(2, 10001):
    DP[i] += DP[i-2]

# 3. 1, 2, 3 만 이용하기
'''
위의 결과에서 똑같이 3을 이용하여 나오는 경우의 숫자 추가해주기
4를 만들때 3이 들어가면 나올 수 있는 경우의 수 1가지
1+3
1 1 2 2 |3|
1 1 2 3 |4|
-> 3의 경우의 수가 더해진 숫자 출력
이걸 10001 번까지 반복 why? 테케가 10000 까지라서
'''
for i in range(3, 10001):
    DP[i] += DP[i-3]

# 이후 입력받은 N에 대하여 DP[N] 수 출력
T = int(input())
for _ in range(T):
    N = int(input())
    print(DP[N])
    
