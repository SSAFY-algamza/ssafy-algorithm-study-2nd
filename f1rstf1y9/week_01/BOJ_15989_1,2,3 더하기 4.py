"""
1. 적용 알고리즘
동적 계획법(DP)

====================================================

2. 문제 풀이를 위한 접근 방식 설명
(편의를 위해 i가 0일 때 경우의 수를 1로 가정)
일단 n은 10000보다 작거나 같으니까 1만 써서 만드는 방법은 모든 수가 1이므로 10000만큼의 크기를 가진 리스트를 만들어서 1로 초기화 해야겠다.

2를 포함하는 경우는 일단 직접 해보자
1 => 1 (1가지)
2 => 1+1 / 2 (1+1 => 2가지)
3 => 1+1 / 1+2 (1+1 => 2가지)
4 => 1+1+1+1 / 1+1+2, 2+2 (1+2 => 3가지)
5 => 1+1+1+1+1 / 1+1+1+2, 1+2+2 (1+2 => 3가지)
6 => 1+1+1+1+1+1 / 1+1+1+1+2, 1+1+2+2, 2+2+2 (1+3 => 4가지)

i라는 수가 1, 2를 포함해서 만들 수 있는 경우의 수는 i-2라는 수가 1,2를 포함해서 만들 수 있는 경우의 수에 1을 더한거구나

3을 포함하는 경우도 해보자.
1 => 1 (1가지)
2 => 1+1, 2 (2가지)
3 => 1+1, 1+2 / 3 (2+1 => 3가지)
4 => 1+1+1+1, 1+1+2, 2+2 / 1+3 (3+1 => 4가지)
5 => 1+1+1+1, 1+1+1+2, 1+2+2 / 1+1+3, 2+3 (3+2 => 5가지)
6 => 1+1+1+1+1+1, 1+1+1+1+2, 1+1+2+2, 2+2+2 / 1+1+1+3, 1+2+3 3+3 (4+3 => 7가지)


i라는 수가 1, 2,3을 포함해서 만들 수 있는 경우의 수는 i가 1,2를 포함해서 만들 수 있는 경우의 수에 i-3이 1,2,3을 포함해서 만들 수 있는 경우의 수를 더한거구나

====================================================

3. 기본 코드에 대한 설명
아래 코드에 주석으로 설명

====================================================

4. 시간 복잡도, 공간 복잡도
시간 복잡도: 각 테스트 케이스마다 O(1)
공간 복잡도: O(1)

"""

T = int(input())

# DP 리스트를 1만을 사용하여 만들 수 있는 방법의 수인 1로 초기화
dp = [1]*10001

# 2를 포함하는 경우 추가 계산
for i in range(2, 10001):
    dp[i] = dp[i-2]+1

# 3을 포함하는 경우 추가 계산
for i in range(3, 10001):
    dp[i] += dp[i-3]

for _ in range(T):
    n = int(input())
    print(dp[n])

