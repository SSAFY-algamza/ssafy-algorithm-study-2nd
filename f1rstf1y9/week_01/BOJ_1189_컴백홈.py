"""
1. 적용 알고리즘
깊이 우선 탐색(DFS) - find_way() 함수로 DFS를 구현

====================================================

2. 문제 풀이를 위한 접근 방식 설명
우선 RxC 맵에 대한 정보를 map_info라는 이차원 리스트에 저장해야겠다고 생각
출발 지점인 map_info[R-1][0]에서 출발해서 도착 지점(집) map_info[0][C-1]까지 K번 이동만에 갈 수 있는 경로를 구하는 문제구나
방문한 곳을 체크하면서 DFS로 경로를 확인하면서 집 위치에 도달했을 때 거리가 K인 경우의 수를 카운트하면 되겠다

====================================================

3. 기본 코드에 대한 설명
아래 코드에 주석으로 설명

====================================================

4. 시간 복잡도, 공간 복잡도
시간 복잡도: O(RC)
공간 복잡도: O(RC)
"""


R, C, K = map(int, input().split())
map_info = [list(input()) for _ in range(R)]

ans = 0 # 집까지 도착하는 경우 중 거리가 K인 가짓 수를 저장할 변수
delta = [(1,0),(0,1),(-1,0),(0,-1)] # 현재 위치에서 이동할 수 있는 방향을 담은 리스트

def find_way(x, y, n): # 현재 위치 (x, y), 출발 지점에서 n만큼 이동
    global ans
    if n == K: # 이동 횟수가 K에 도달하면 일단 멈춰!
        if (x,y) == (0,C-1): # K번만에 집에 도착했네? ans 변수에 횟수 1 추가
            ans += 1
    else:
        for dx, dy in delta: # 이동할 수 있는 방향 구석구석 살피기
            nx, ny = x+dx, y+dy
            if 0 <= nx < R and 0 <= ny < C and map_info[nx][ny] != 'T': # 범위를 벗어나지 않고, 해당 위치가 T가 아니라면 이동
                map_info[nx][ny] = 'T' # 이미 방문한 곳은 T로 체크해서 중복으로 방문하지 않도록 하기
                find_way(nx, ny, n+1)
                map_info[nx][ny] = '.' # 다른 길을 찾기 위해 다시 .으로

map_info[R-1][0] = 'T' # 출발지 방문 체크
find_way(R-1,0,1) # 문제에서 시작부터 거리를 1로 세길래 출발지 위치와 1을 인자로 넘겨줌
print(ans)